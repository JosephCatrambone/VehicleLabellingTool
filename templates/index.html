<HTML>
<HEAD>
</HEAD>
<BODY>
	<div>
		<canvas id="mainCanvas" width="512", height="512"></canvas> <!-- Note, we're upscaling canvas by 4x. -->
	</div>
	</div>
		<button id="newPatch">Get Patch</button>
		<button id="selectTool">Selection Tool</button>
		<button id="createTool">Create Tool</button>
		<button id="moveTool">Move Tool</button>
		<button id="forwardTool">Forward Tool</button>
		<input id="placeMultiple" value="placeMultiple" type="checkbox">Place Multiple <!-- If checked, will switch between place and forward as each operation is completed. -->
	</div>
	
	<script type="text/javascript">
	(function() {
		var SELECTED_COLOR = "rgba(0,255,0,1.0)";
		var UNSELECTED_COLOR = "rgba(50,155,50,0.8)";
		var RECT_SIZE = 2;
		var MAX_SELECTION_DISTANCE = 100;
	
		var httpRequest;
		var canvasElement = document.getElementById("mainCanvas");
		var ctx = canvasElement.getContext('2d');
		var img = null;
		var xOffset = 0;
		var yOffset = 0;
		var patchId = 0;
		var imgName = "";
		var editorMode = "SELECT";
		var currentPoint = -1;
		var pointList = [];
		
		document.getElementById("newPatch").onclick = function() { pushData(); };
		document.getElementById("selectTool").onclick = function() { editorMode = "SELECT"; };
		document.getElementById("createTool").onclick = function() { editorMode = "CREATE"; };
		document.getElementById("moveTool").onclick = function() { editorMode = "MOVE"; };
		document.getElementById("forwardTool").onclick = function() { editorMode = "FORWARD"; };
		
		canvasElement.onmouseup = function(evt) {
			var coord = canvasElement.relMouseCoords(event);
			if(editorMode == "SELECT") {
				var mouseX = coord.x/canvasElement.width;
				var mouseY = coord.y/canvasElement.height;
				currentPoint = -1;
				var nearestPoint = -1;
				var nearestDistance = 10000000000;
				for(var i=0; i < pointList.length; i++) {
					var dx = mouseX-pointList[i].transform.x;
					var dy = mouseY-pointList[i].transform.y;
					var dist = dx*dx+dy*dy;
					if(dist < nearestDistance) {
						nearestPoint = i;
						nearestDistance = dist;
					}
				}
				if(nearestDistance < MAX_SELECTION_DISTANCE) {
					currentPoint = nearestPoint;
				}
			} else if(editorMode == "CREATE") {
				var newPoint = {'transform':{'x':coord.x/canvasElement.width, 'y':coord.y/canvasElement.height}, 'forward':{'x':(coord.x+1)/canvasElement.width, 'y':(coord.y+1)/canvasElement.height}};
				pointList.push(newPoint);
				currentPoint = pointList.length-1;
				
				if(document.getElementById("placeMultiple")) {
					editorMode = "FORWARD";
				}
			} else if(editorMode == "MOVE") {
				if(currentPoint == -1) { return; }
				var pt = pointList[currentPoint];
				pt.transform.x = coord.x/canvasElement.width;
				pt.transform.y = coord.y/canvasElement.height;
			} else if(editorMode == "FORWARD") {
				if(currentPoint == -1) { return; }
				var pt = pointList[currentPoint];
				pt.forward.x = coord.x/canvasElement.width;
				pt.forward.y = coord.y/canvasElement.height;
				
				if(document.getElementById("placeMultiple")) {
					editorMode = "CREATE";
				}
			}
			//pushData(img.width*(coords.x/canvasElement.width), img.height*(coords.y/canvasElement.height));
			redraw();
		}

		function makeRequest(url, postMethod, toSend, onSuccess, onError) {
			if (window.XMLHttpRequest) {
				httpRequest = new XMLHttpRequest();
			} else if (window.ActiveXObject) {
				try {
					httpRequest = new ActiveXObject("Msxml2.XMLHTTP");
				} 
				catch (e) {
					try {
						httpRequest = new ActiveXObject("Microsoft.XMLHTTP");
					} 
					catch (e) {}
				}
			}

			if (!httpRequest) {
				alert('Unable to instance httpRequest object.');
				return false;
			}
			
			httpRequest.onreadystatechange = function() {
				if (httpRequest.readyState === 4) {
					if (httpRequest.status === 200) {
						if(onSuccess) { onSuccess(httpRequest.responseText) };
					} else {
						if(onError) { onError() };
					}
				}
			};
			httpRequest.open(postMethod, url);
			if(toSend != null) {
				httpRequest.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
				httpRequest.send("json=" + encodeURIComponent(JSON.stringify(toSend)));
			} else {
				httpRequest.send();
			}
			return true;
		}
		
		function defaultErrorPopup() {
			alert("There was a problem reading data from the server.");
		}
		
		function updateData(responseText) {
			json = JSON.parse(responseText);
			xOffset = json['offset_x'];
			yOffset = json['offset_y'];
			patchId = json['patch_id'];
			imgName = json['filename'];
			pointList = json['points'];
			
			// Redraw the image
			img = new Image;
			img.onload = function () {
				ctx.drawImage(this, 0, 0, canvasElement.width, canvasElement.height);
			}
			img.src = "data:image/png;base64," + json['data'];

			redraw();
		}
		
		function pushData() {
			// TODO: We should encapsulate this better and make it depend less on the globals.
			var onSuccess = function(msg) { 
				pointList = [];
				makeRequest('get_work', 'GET', null, updateData, defaultErrorPopup);
			}; // Get a new image if this posts.
			var onFailure = function(msg) { alert("Unable to push current data to server.  Please wait a moment and try again.  Error data: " + msg); };
			makeRequest('submit_result', 'POST', {"filename":imgName, 'patch_id':patchId, 'x_offset':xOffset, 'y_offset':yOffset, 'points':pointList}, onSuccess, onFailure);
		}
		
		function redraw() {
			ctx.drawImage(img, 0, 0, canvasElement.width, canvasElement.height); // Draw background image.
			
			// Draw objects
			for(var i=0; i < pointList.length; i++) {
				if(i == currentPoint) { 
					ctx.strokeStyle = SELECTED_COLOR;
				} else {
					ctx.strokeStyle = UNSELECTED_COLOR; // Perhaps slightly inefficient to re-set stroke style every time.  We could just draw only the selected point over top of itself.
				}
				ctx.strokeRect((pointList[i].transform.x*canvasElement.width)-RECT_SIZE, (pointList[i].transform.y*canvasElement.height)-RECT_SIZE, 2*RECT_SIZE, 2*RECT_SIZE);
				ctx.beginPath();
				ctx.moveTo(pointList[i].transform.x*canvasElement.width, pointList[i].transform.y*canvasElement.height);
				ctx.lineTo(pointList[i].forward.x*canvasElement.width, pointList[i].forward.y*canvasElement.height);
				ctx.stroke();
			}
		}
		
		// From O'Reilly's method
		function relMouseCoords(event){
			var totalOffsetX = 0;
			var totalOffsetY = 0;
			var canvasX = 0;
			var canvasY = 0;
			var currentElement = this;

			do{
				totalOffsetX += currentElement.offsetLeft - currentElement.scrollLeft;
				totalOffsetY += currentElement.offsetTop - currentElement.scrollTop;
			} while(currentElement = currentElement.offsetParent);

			canvasX = event.pageX - totalOffsetX;
			canvasY = event.pageY - totalOffsetY;

			return {x:canvasX, y:canvasY}
		}
		HTMLCanvasElement.prototype.relMouseCoords = relMouseCoords;
		
		// coords = canvas.relMoueCoords(event) -> coords.x
		
	})();
	</script>
</BODY>
